import { AsyncLocalStorage } from "node:async_hooks";
import { execFile, spawn } from "node:child_process";
const processContext = new AsyncLocalStorage();
let processObserver = null;
export function setProcessObserver(next) {
    processObserver = next;
}
export function getProcessContext() {
    return processContext.getStore() ?? {};
}
export function runWithProcessContext(ctx, fn) {
    return processContext.run(ctx, fn);
}
function registerProcess(info) {
    if (!processObserver)
        return null;
    const ctx = getProcessContext();
    return processObserver.register({
        ...info,
        runId: info.runId ?? ctx.runId ?? null,
        source: info.source ?? ctx.source ?? null,
    });
}
function attachLineReader(stream, onLine) {
    if (!stream)
        return;
    let buffer = "";
    stream.setEncoding("utf8");
    stream.on("data", (chunk) => {
        buffer += chunk;
        const lines = buffer.split(/\r?\n/);
        buffer = lines.pop() ?? "";
        for (const line of lines) {
            if (line === "")
                continue;
            onLine(line);
        }
    });
    stream.on("end", () => {
        const line = buffer.trim();
        if (line)
            onLine(line);
        buffer = "";
    });
}
export function trackChildProcess(proc, info, options) {
    const handle = registerProcess(info);
    if (!handle)
        return null;
    handle.setPid(proc.pid ?? null);
    const captureOutput = options?.captureOutput !== false;
    if (captureOutput) {
        attachLineReader(proc.stdout, (line) => handle.appendOutput("stdout", line));
        attachLineReader(proc.stderr, (line) => handle.appendOutput("stderr", line));
    }
    let finished = false;
    const finishOnce = (result) => {
        if (finished)
            return;
        finished = true;
        handle.finish(result);
    };
    proc.on("error", (error) => {
        const message = error instanceof Error ? error.message : String(error);
        finishOnce({ exitCode: null, signal: null, error: message });
    });
    proc.on("close", (code, signal) => {
        finishOnce({ exitCode: code ?? null, signal: signal ?? null });
    });
    return handle;
}
export function spawnTracked(command, args, options = {}) {
    const { label, kind, runId, source, captureOutput, ...spawnOptions } = options;
    const proc = spawn(command, args, spawnOptions);
    const handle = trackChildProcess(proc, {
        command,
        args,
        label,
        kind,
        runId,
        source,
        cwd: spawnOptions.cwd ? String(spawnOptions.cwd) : null,
        env: spawnOptions.env ?? null,
    }, { captureOutput });
    return { proc, handle };
}
export function execFileTracked(file, args, options, callback) {
    let resolvedArgs = [];
    let resolvedOptions = {};
    let resolvedCallback;
    if (Array.isArray(args)) {
        resolvedArgs = args;
        if (typeof options === "function") {
            resolvedCallback = options;
        }
        else {
            resolvedOptions = options ?? {};
            resolvedCallback = callback;
        }
    }
    else if (typeof args === "function") {
        resolvedCallback = args;
    }
    else {
        resolvedOptions = (args ?? {});
        if (typeof options === "function") {
            resolvedCallback = options;
        }
    }
    const proc = execFile(file, resolvedArgs, resolvedOptions, resolvedCallback);
    trackChildProcess(proc, {
        command: file,
        args: Array.from(resolvedArgs),
        label: file,
        kind: file,
        cwd: resolvedOptions.cwd ? String(resolvedOptions.cwd) : null,
        env: resolvedOptions.env ?? null,
    }, { captureOutput: true });
    return proc;
}
//# sourceMappingURL=processes.js.map